---
phase: 01-foundation-setup
plan: 02
type: execute
---

<objective>
Integrate SQLite database with better-sqlite3 and create database utilities for local data persistence.

Purpose: Establish the local-first database layer that will store all financial data without any external services, ensuring complete privacy.
Output: Working SQLite database with connection utilities, initialization script, and type-safe query helpers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-setup/01-01-SUMMARY.md

**From Plan 01:**
- Next.js project structure established
- Environment template with DATABASE_PATH
- data/ directory created for database file

**Constraints:**
- Privacy-first: All data stays local in SQLite file
- No cloud database services
- Database file stored in data/ directory (gitignored)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install better-sqlite3 and create database client</name>
  <files>package.json, lib/db.ts, .env.local</files>
  <action>
    Install better-sqlite3 (synchronous SQLite library, perfect for Next.js):
    - `pnpm add better-sqlite3`
    - `pnpm add -D @types/better-sqlite3`

    Create `lib/db.ts` database client:
    ```typescript
    import Database from 'better-sqlite3';
    import path from 'path';

    const dbPath = process.env.DATABASE_PATH || './data/finance.db';
    const dbDir = path.dirname(dbPath);

    // Ensure data directory exists
    import fs from 'fs';
    if (!fs.existsSync(dbDir)) {
      fs.mkdirSync(dbDir, { recursive: true });
    }

    // Create database connection
    export const db = new Database(dbPath, { verbose: console.log });

    // Enable foreign keys
    db.pragma('foreign_keys = ON');

    // Helper for transactions
    export const transaction = db.transaction;

    // Close database on process exit
    process.on('exit', () => db.close());
    process.on('SIGHUP', () => process.exit(128 + 1));
    process.on('SIGINT', () => process.exit(128 + 2));
    process.on('SIGTERM', () => process.exit(128 + 15));
    ```

    Create `.env.local` with actual database path:
    ```
    DATABASE_PATH=./data/finance.db
    ```

    Use better-sqlite3 (NOT node-sqlite3) because:
    - Synchronous API (simpler, no async/await complexity)
    - Faster for most operations
    - Better for Next.js server components (no async issues)
    - No native module compilation issues
  </action>
  <verify>
    - better-sqlite3 in package.json dependencies
    - lib/db.ts exports db instance and transaction helper
    - .env.local exists with DATABASE_PATH
    - `pnpm tsc --noEmit` passes
  </verify>
  <done>
    - better-sqlite3 installed with types
    - Database client created with foreign key support
    - Environment configured with database path
    - No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database initialization script with version tracking</name>
  <files>lib/db-init.ts, lib/migrations/</files>
  <action>
    Create `lib/db-init.ts` to initialize database with version tracking:

    ```typescript
    import { db } from './db';

    export function initializeDatabase() {
      // Create version tracking table
      db.exec(`
        CREATE TABLE IF NOT EXISTS _meta (
          key TEXT PRIMARY KEY,
          value TEXT NOT NULL
        )
      `);

      // Check current version
      const versionRow = db.prepare('SELECT value FROM _meta WHERE key = ?').get('schema_version') as { value: string } | undefined;
      const currentVersion = versionRow ? parseInt(versionRow.value) : 0;

      console.log(\`Database schema version: \${currentVersion}\`);

      // Version 1 will be applied in Phase 2 (Core Data Models)
      // This file just ensures _meta table exists for version tracking

      if (currentVersion === 0) {
        db.prepare('INSERT INTO _meta (key, value) VALUES (?, ?)').run('schema_version', '0');
        console.log('Database initialized with version tracking');
      }

      return currentVersion;
    }
    ```

    Create `lib/migrations/` directory for future schema migrations (Phase 2 will add migration files).

    This approach:
    - Tracks schema version for future migrations
    - Doesn't create any tables yet (Phase 2 handles schema)
    - Idempotent (safe to run multiple times)
    - Ready for migration system in next phase
  </action>
  <verify>
    - lib/db-init.ts exports initializeDatabase function
    - lib/migrations/ directory exists
    - `pnpm tsc --noEmit` passes
    - Running initializeDatabase() creates _meta table in data/finance.db
  </verify>
  <done>
    - Database initialization script created
    - Version tracking table implemented
    - Migrations directory ready for Phase 2
    - No errors when initializing database
  </done>
</task>

<task type="auto">
  <name>Task 3: Add database initialization to app startup and create health check endpoint</name>
  <files>app/api/health/route.ts, lib/db.ts (update)</files>
  <action>
    Update `lib/db.ts` to auto-initialize on import:
    ```typescript
    // Add at end of file, after db creation
    import { initializeDatabase } from './db-init';

    // Initialize database on first import
    if (process.env.NODE_ENV !== 'test') {
      initializeDatabase();
    }
    ```

    This ensures database is ready whenever db client is imported.

    Create `app/api/health/route.ts` API endpoint to verify database connection:
    ```typescript
    import { NextResponse } from 'next/server';
    import { db } from '@/lib/db';

    export async function GET() {
      try {
        // Simple query to verify database works
        const result = db.prepare('SELECT 1 as ok').get();

        return NextResponse.json({
          status: 'healthy',
          database: 'connected',
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        return NextResponse.json({
          status: 'unhealthy',
          database: 'error',
          error: error instanceof Error ? error.message : 'Unknown error'
        }, { status: 500 });
      }
    }
    ```

    This health check endpoint:
    - Verifies database connection works
    - Useful for debugging
    - Will be used in later phases to check database state
  </action>
  <verify>
    - lib/db.ts calls initializeDatabase() on import
    - app/api/health/route.ts exists
    - `pnpm dev` starts without database errors
    - curl http://localhost:3000/api/health returns {"status":"healthy","database":"connected"}
    - data/finance.db file exists with _meta table
  </verify>
  <done>
    - Database initializes automatically on app startup
    - Health check endpoint returns success
    - SQLite database file created in data/ directory
    - Database connection verified working
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm dev` starts without database errors
- [ ] data/finance.db file exists
- [ ] curl http://localhost:3000/api/health returns healthy status
- [ ] `pnpm build` succeeds
- [ ] `pnpm tsc --noEmit` passes with no errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- SQLite database file created and accessible
- Database initialization runs successfully
- Health check endpoint confirms database connection
- No errors in development or production build
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-setup/01-02-SUMMARY.md`:

# Phase 1 Plan 2: SQLite Integration Summary

**Local SQLite database integrated with better-sqlite3, automatic initialization, and health check endpoint.**

## Accomplishments

- better-sqlite3 installed for synchronous SQLite operations
- Database client created with foreign key support and proper cleanup
- Version tracking system implemented for future migrations
- Database auto-initializes on application startup
- Health check API endpoint verifies database connectivity

## Files Created/Modified

- `lib/db.ts` - Database client with auto-initialization
- `lib/db-init.ts` - Database initialization with version tracking
- `lib/migrations/` - Directory for future schema migrations
- `app/api/health/route.ts` - Health check endpoint
- `.env.local` - Environment with DATABASE_PATH
- `data/finance.db` - SQLite database file (gitignored)
- `package.json` - Added better-sqlite3 and types

## Tech Stack Added

- better-sqlite3 (synchronous SQLite library)
- SQLite database (local file-based storage)

## Decisions Made

- **better-sqlite3 over node-sqlite3**: Synchronous API is simpler and faster for most operations, better for Next.js server components
- **Version tracking from start**: _meta table with schema_version enables safe migrations in future phases
- **Auto-initialization**: Database initializes on first import, no manual setup needed

## Issues Encountered

None expected - better-sqlite3 has excellent Windows/Mac/Linux support.

## Next Phase Readiness

Ready for Phase 1 Plan 3 (PWA manifest). Database foundation complete, Phase 2 can add schema tables.
</output>
